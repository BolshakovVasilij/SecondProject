# **ШПАРГАЛКА   ПО РАБОТЕ С Git**  
---


## **Тема №1 Командная строка и начало работы с Git**  


### Система контроля версий, или VCS, — это программное обеспечение, которое помогает отслеживать изменения в программах, текстовых файлах, больших документах, веб-сайтах и так далее.  


Основные функции системы контроля версий:  
* хранит историю изменений в виде отдельных ревизий;  
* позволяет манипулировать историей: например, менять порядок ревизий, полностью удалять версии, возвращаться назад в истории;  
* помогает анализировать изменения: например, кто и когда вносит изменения, кто чаще всего вносит изменения в определённый файл и так далее.  
**Git — один из примеров системы контроля версий: он позволяет хранить, изменять и анализировать историю проекта**.  


### Основные команды командной строки Git Bash:  
1. *pwd* - вывести текущую директорию.  
2. *cd ~* - вывести домашнюю директорию.  
3. *ls* - вывести содержимое текущей папки, с флагом -a выводится расширенный список со скрытыми файлами.  
4. *cd "название папки, путь"* - сменить директорию, если в названии есть пробелы, то оно записывается в кавычках, cd .. - переход на уровень выше., cd . - обратиться к текущей директории.  
5. *touch*- создание файла.  
6. *mrdir* - создание папки, с помощью флага -p создается структура директорий.  
7. *cp что_копируем куда_копируем* - копирование файлов (папок).  
8. *mv - что_перемещаем куда_перемещаем* - перемещение файлов (папок).   
9. *cat* - чтение файлов (только с текстовыми файлами).  
10. *rm* - удаление файла (папки), с флагом -r - удаление папки с содержимым, рекрсивное удаление.  
11. *rmdir* - удаление пустой папки.  
12. *&&* - с помощью разделителя в виде двух амперсандов можно выполнять список команд.  


### Основные команды работы с Git:  
1. *$ git version* - вывести текущую версию установленного Git.  
2. *$ git config --global user.name "User Namovich"* (имя или ник нужно написать латиницей и в кавычках).  
*$ git config --global user.email username@yandex.ru* (здесь нужно указать свой настоящий email).  
3. *$ cat ~/.gitconfig*  или *$ git config --list*  - проверка настройки Git.  


### Команды инициализации Git:  
1. *$ git init* - создание репозитория из текущей папки.  
2. *$rm -rf .git* - способ "разгитить" репозиторий.  
3. *$ git status* - проверка состояния репозитория (название текущей ветки, коммиты).  
4. *$ git add файл.html (--all)* - подготовка к сохранению файла (всех файлов git add .).  
5. *$ git commit файл.html -m* "Содержание изменения" - сохранение файла.  
6. *$ git log* - просмотр истории коммитов.  


## **Тема №2 Начало работы с GitHub**  


### GitHub — платформа для хранения IT-проектов и совместной работы над ними с использованием Git.  
### Типы проектов GitHub: приватный, командный, публичный.  
### Порядок создания репозитория:  
1. Создать удаленный репозиторий на сайте GitHub.  
2. При необходимости сгенрировать SSH-ключи (от англ. Secure Shell Protocol).  
SSH использует пару ключей для обеспечения безопасности — публичный и приватный:  
Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для шифрования данных.  
Публичный ключ (англ. public key) доступен всем и используется для расшифровки данных, которые были зашифрованы приватным ключом.  
*$ ls -la .ssh/* - проверка наличия созданных ключей в домашней директории.  
*$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"* - генерация SSH-пары ключей (возможно потребуется изменить алгоритм шифрования  rsa -b 4096), использование кодовой фразы не обязательно.  
*$ clip < ~/.ssh/id_ed25519.pub*  -  скопировать содержимое ключа в буфер обмена:  
*$cat ~/.ssh/id_ed25519.pub* - либо вывод на экран.  
В меню Settings GitHub в пункте SSH and GPG keys выбрать New SSH key. В поле Title написать название ключа. В поле Key type должно быть Authentication Key. В поле Key скопировать ключ из буфера обмена, затем Add SSH key.  
3. *$ ssh -T git@github.com.*  - проверка правильности ключа.  
4. Перейти на страницу удалённого репозитория, выбрать тип SSH и скопировать URL. Затем перейти в каталог (папку) локального репоизтория и ввести:  
*$ git remote add origin git@github.com:ИМЯ_АККАУНТА/название_проекта.git.*  
5. Проверка того, что репозитории связаны:  
*$ git remote -v*, должно быть:  
*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)*  
*origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)*  
6. *$ git push -u origin master* - отправка изменений на удаленный репозиторий.  
### Содержание файла README.md.  
Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.  
Технологии, которые применяются в проекте. В чём е го отличие от аналогичных.  
Документация проекта — подробная инструкция о том, что представляет собой проект.  
###  Хеш — идентификатор коммита  
**Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).**  
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.  
Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.  
**$ git log --oneline** - получение сокращенного лога.  
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).  
### Статусы файлов в репозитории  
* **untracked** - неотслеживаемый.
* **staged** - подготовленный, после выполнения команды **git add** файл попадает в staging area, то есть в список файлов, которые войдут в коммит. Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.  
* **tracked** - отслеживаемый, в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add.  
* **modified** - измененный, Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия.  
###   Жизненный цикла файла Git  
```mermaid
flowchart TD
A["Файл только что создали. Git про него ещё ничего не знает"]--Состояние: untracked --> B{"Файл добавили в staging area с помощью git add"};
B--Yes.Состояние: staged + tracked-->C{"Изменили файл еще раз"};
B--No.Состояние: untracked-->D["Файл не отслеживается"];
C--Yes.Состояния: staged, modified + tracked-->E{"staged и modified у одного файла,<br> но у разных его версий.Ещё раз выполнили git add"};
C--No.Состояние: staged + tracked-->F["Состояние не изменилось"];
E--Yes.Состояние staged + tracked-->G{"Сделали коммит с помощью git commit"}
G--Yes.Состояние: tracked-->I["Файл отслеживается"]-->C;
G--No.Состояние staged+ tracked-->F;
```
Состояния файла в git status:  
* staged (Changes to be committed в выводе git status);  
* modified (Changes not staged for commit);  
* untracked (Untracked files).  
Jira — система для организации проектов и задач.  
Стандарт Conventional Commits, формат коммита: < type >: <сообщение>.:  
* feat (англ. «навык») — для новой функциональности;  
* fix (от англ. «исправить», «устранить») — для исправленных ошибок.  
### Внесение в правок в commit  
Команда **git commit --amend --no-edit** - внести правки в уже сделанный последний коммит, например дополнить изменение забытым файлом, при этом последняя опция говорит, что сообщение коммита менять не нужно.  
* Команда **git commit --amend -m "новое сообщение"** - внести правки в сообщение о коммите.  
* Команда **git restore --staged file** - убрать файл из коммита (staging area).  
* Команда **git reset --hard commit hash** - "откатить" то, что уже было закоммичено, возвращение репозитория к более раннему, при этом вся дальнейшая разработка будет вестись от файла с указанным хешем. Файл вернется к тому состоянию, в котором был в момент этого коммита. Более поздние коммиты Git удалит.  
* Команда **git restore file** - отменить изменения файла modified.  
* Команда  **git diff** - просмотреть изменения файла в сравнении с последней закоммиченной версией (git diff A B - превращение состояния А в В).  
* Команда **git diff --staged** - просмотр изменений в файлах добавленных в коммит.  
* Команда **echo "Новая строка" >> file.txt** - запись в файл дополнительной строки (если использовать символ ">" то исходный текст в файле будет стерт).  
* файл .gitignore - файл, в котором находится информация о файлах, изменения которых не должны отслеживаться git (#комментарии, .new_file, * - игнорировать файлы "tmp" во всех подпапках папки docs docs/*/tmp (для шаблонов), ? - любой один символ, [...] - один символ из списка в квадратных скобках, / - обозначение каталогов, ** - вся вложенная структура, ! - инвертирование правил).  
* команда **git  status --ignored** - отобразить все игнорируемые файлы.  
## **Тема №3 Работа с ветками** 
### Процесс копирования удалённого репозитория на локальный компьютер называется клонированием.
* открыть на GitHub репозиторий, который необходимо клонировать;  
* скопировать SSH из зеленой вкладки <>Code;  
* Команда **git clone https://github.com/скопированный SSH** - создание копию удаленного репозитория на локальном компьютере и автоматически связывает локальный и удаленный репозиторий, **git remote -v** - проверка того, что репозитории связаны;  
### GitHub-операция Fork (вилка) - создание копии репозитория в аккаунте GitHub  
В процессе «форка» создаётся копия всех файлов, истории коммитов и веток. Эта копия сохраняется в вашей учётной записи GitHub. Для применения Fork в GitHub выбираем вкладку Fork и нажимаем Create Fork  
Причины использования «форков»:  
* Необходимо внести свой вклад в проект, но не имеете прав на изменение исходного репозитория. Тогда вы можете сделать «форк», добавить нужные правки, а затем отправить запрос на включение этих изменений в оригинальный проект;
* Необходимо развивать проект независимо от исходного;  
* Обычно комбинация «форк» + clone используется для внесения изменений в публичные репозитории. В этом случае «форк» становится подготовительным этапом перед клонированием чужого репозитория на ваш компьютер. Если репозиторий приватный или это репозиторий вашей компании, при работе с ним достаточно clone.  
### Branch (ветка) - изолированный поток разработки проекта  
* Команда **git branch** - показывает все ветки, которые естьт в проекте, символом (*) показана ветка, в которой вы находитесь в текущий момент.  
* Команда **git branch название ветки** - создание ветки.  Название ветки можеgitт представлять собой следующую запись: указатель (например feature)/описание-решаемой-задачи.  
* Команда **git checkout название_ветки** - переключение на другую ветку.  
* Команда **git checkout -b название_ветки** - создать ветку и сразу переключиться не нее.  
* Команда **git diff** - показывает изменения в modified-файлах.
* Команда **git diff название_ветки1 название_ветки2** - сравнение двух веток. Также можно сравнивать название ветки и хеш коммита.  
* Суффикс навигации **~N** - где N - это число, он отсчитывает от заданного коммита N коммитов назад во времени, при этом нумерация начинается с 0 (HEAD~1 — это следующий за текущим коммит. А main~5 — это пятый коммит в ветке main, если считать с последнего выполненного коммита). Если необходимо перейти на предыдущий можно написать сивол *~* без цифры.
* Команда **git merge название_ветки** - слияние веток. Запускать команду необходимо из основной ветки.  
* Команда **git branch -D название_ветки** - удаление ветки-донора. **git branch -d название_ветки** - безопасный вариант удаления, удаление произойдет только если ветка полностью объединена с другой. Удаление локальной ветки через Git не удаляет ветку на GitHub.  
* Команда **git push -u origin my-branch** - отправить локальную ветку в удаленный репозиторий.
* Команда **git pull** - скачать изменения из удаленного репозитория, сначала необходимо перейти в требуюмую ветку. Как правило, git pull - первая команда, которую  вводит разработчик, как только открывает код проекта, чтобы начать с ним работать. Дополнительно git pull и git merge выполняют перед тем, как создать пул-реквест.
## **Тема №4 Совместная работа в Git**  

* **merge --no-ff add-docs** - отключение Fast-forward слияния веток.  
* **merge.ff:git config [--global] merge.ff false** - отключение Fast-forward слияния веток навсегда.  
* **git push --force** - "форсированный пуш" (для того чтобы справиться с ошибкой слияния веток non-fast-forward), приведет к удалению коммитов из удаленного репозитория до состояния fast-forward (редко уместная команда).  
* **rebase** - перебазирование, изменение точки от которой отделилась ветка на точку после коммитов до состояния fast-forward.  

***Подходы (модели, стратегии) к работе с ветками*** — это правила, которые описывают, когда и для чего создаются ветки, какие в них коммиты и в какой момент происходит слияние веток.  
* **Feature branch workflow** — для каждого нового изменения создаётся новая ветка, которая позже вливается в main с помощью git merge.  
Работа над люьой новой функциональностью или исправлением ведется в отдельной ветке под конкретную задачу. Когда ветка готова она вливается в ветку master.
* **Git flow** - создается больше веток, а коммиты делят на разные типы: исправления, новая функциональность. Разные типы коммитов попадают в разные ветки.
* **trunk-based** - участники проекта вливают (merge) свой код в основную ветку максимально часто.

***Pull (или merge) request*** - запрос на слияние: запустить автоматические тесты, которые покажут, не «сломают» ли новые изменения уже существующую в проекте логику либо просмотреть изменения «глазами» — это называется code review (англ. «осмотр», «рецензия кода») или просто review.  
1. Автор создаёт пул-реквест.  
2. Ревьюер просматривает изменения и предлагает правки, если они необходимы.  
3. Автор вносит исправления по комментариям ревьюера.  
4. Второй и третий пункты могут повториться!  
5. Если ревьюера всё устраивает, он одобряет («апрувит») пул-реквест.  
6. Теперь автор или ревьюер могут влить изменения в основную ветку.  

***Навыки специалиста принято делить на две группы:*** **hard skills** (англ. «жёсткие навыки») и **soft skills** (англ. «мягкие навыки», «гибкие навыки»).
* **Hard skills**, или хардскилы, — это владение инструментами, причём неважно какими. Умение забивать гвозди молотком, знание команд Git, умение играть на пианино — всё это примеры хардскилов. Именно этому типу навыков мы уделяли больше внимания в нашем курсе.
* **Soft skills**, или софтскилы, — это социально-психологические навыки. Например: умение договариваться, умение внятно донести свои мысли или понять идеи собеседника, умение мягко преподнести критику результатов работы.

Инструмент слияния ***vimdiff***
* **git mergetool** - вызов инструмента слияния, показывает четыре окна: в верхнем левом углу — текущая версия файла в HEAD; в правом верхнем углу — версия из ветки br2; посередине сверху — версия из ветки, которая является общим предком, то есть из main; снизу — результат изменения с маркерами конфликта.
***Алгоритм-шпаргалка для создания PR***
1. Склонировать репозиторий.  
    1. Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.
    2. На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.  
    3. Выполнить команду *git clone <ссылка на репозиторий>*.  
2. Создать ветку для вашей задачи: git checkout -b my-task-branch-name.  
3. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.  
4. «Запушить» ветку: git push *--set-upstream origin HEAD* или *git push -u origin my-task-branch-name*.  
    1. GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.  
    2. PR можно также создать через интерфейс GitHub.  
5. Сообщить о пул-реквесте ревьюеру.  
    1. Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.  
6. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).  
    1. Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью, нужно разрешить конфликт:  
* Обновить main: *git checkout main && git pull*.  
* Влить main в свою ветку: *git checkout my-task-branch-name && git merge main*.  
* Разрешить конфликты слияния с помощью IDE или вручную.  
* Создать коммит слияния: *git commit --no-edit или git commit -m 'merge main'*.  
* Сделать *git push* своей ветки.  
7. Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.  
8. Ещё раз обновить main, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: *git checkout main && git pull*.  

***Алгоритм-шпаргалка для разрешения конфликтов слияния***
1. Открыть проект в IDE (VS Code, IDEA или другие).  
2. Открыть файл, в котором есть конфликт.  
3. Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.  
4. Когда конфликты разрешены, сделать коммит: *git commit --no-edit или git commit -m 'merge branch <название ветки>'*.  